---
title: JavaScript ass√≠ncrono
pubDate: '2022-02-23'
description: 'Mais detalhes de como funcionam as funcionalidades ass√≠ncronas do JavaScript.'
tags: [javascript, async, await, assincrono, callstack, eventloop, closure]
keywords: [javascript, async, await, assincrono, callstack, eventloop, closure]
heroImage: '/img/javascript-async.jpeg'
---

<img
  src="/img/javascript-async.jpeg"
  alt="JavaScript ass√≠ncrono"
  class="w-full h-[30rem] object-cover"
/>

---

## O b√°sico

Se voc√™ utiliza JavaScript a algum tempo provavelmente j√° utilizou conceitos
ass√≠ncronos, desde os famosos `setTimeout`/`setInterval`, `Promise`, `async`/`await`
e coisas do tipo.

Primeiramente gostaria de destacar como o JavaScript funciona por debaixo dos
panos, tornando mais f√°cil o entendimento do que seria essa assincronicidade.

## Event Loop and Event Queue

Para quem conhece JavaScript um pouco al√©m do b√°sico j√° deve ter ouvido falar na
famosa arquitetura de Event Loop.

O Event Loop nada mais √© que uma forma c√≠clica de executar as a√ß√µes que mandamos
para o JavaScript, com isso o processo s√≥ √© finalizando quando n√£o existem mais
eventos a serem executados ou por outros motivos, como um erro que quebra essa
fila. Um exemplo de c√≥digo para o Event Loop seria algo como:

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

J√° a Event Queue nada mais √© que a fila que ger√™ncia a ordem de execu√ß√£o dessas
mensagens pelo Event Loop, ou seja, se tratando de uma fila, o primeiro evento 
que √© executado √© o primeiro a chegar na fila, ent√£o como lidamos como uma fila
e uma mensagem vai em seguida da outra chamamos de c√≥digo s√≠ncrono, pois
uma mensagem s√≥ ser√° processada ap√≥s a outra.

![JavaScript Async](/img/event-loop.jpeg)

## Eventos ass√≠ncronos

Bom, pelo que comentei antes os eventos acontecem todos sincronamente, ent√£o de
que forma eram tratados os eventos ass√≠ncronos antes de termos API's de alto
n√≠vel como `Promise` e `async`/`await`? Existem v√°rias formas e uma delas √© bem
comum de utilizar no browser, que √© o padr√£o `Observer`, no caso um `listener`
fica "ouvindo" altera√ß√µes de um determinado evento. Um exemplo √© a antiga API para
fazer requisi√ß√µes, o saudoso `XMLHttpRequest`:

```js
const xmlHttp = new XMLHttpRequest();
xmlHttp.responseType = 'json';
const url = 'https://api.github.com/users/azagatti';
xmlHttp.onreadystatechange = () => {
  // other implementations
  console.log(xmlHttp.response);
};
xmlHttp.open('GET', url);
xmlHttp.send(null);
```

Nesse caso registramos uma fun√ß√£o na propriedade `onreadystatechange` da vari√°vel
com a inst√¢ncia do `XMLHttpRequest` e ent√£o, quando usando o `send` recebemos o
retorno desse dado no `response`, por isso toda a l√≥gica de quando o dado for
recebido dever√° ficar dentro dessa fun√ß√£o atribu√≠da ao `onreadystatechange`.

Um outro exemplo cl√°ssico de programa√ß√£o ass√≠ncrona √© o `setTimeout`
(e `setInterval`), onde a fun√ß√£o atribu√≠da √© executada ap√≥s o tempo informado,
mas um exerc√≠cio cl√°ssico sobre essa fun√ß√£o, qual a ordem de execu√ß√£o desses
logs? ü§î

```js
setTimeout(() => {
  console.log('1');
}, 0);
console.log('2');
```

A ordem dos logs √©: 2 -> 1. Isso por que o `setTimeout` entra na fila de eventos
ass√≠ncronos, mesmo o tempo informado sendo 0, a Event Queue vai priorizar a
execu√ß√£o dos dados s√≠ncronos, s√≥ ent√£o a fun√ß√£o no `setTimeout` ser√° executada.

## Promise

`Promise` √© um conceito abrangente do que o pr√≥prio nome j√° diz, √© uma promessa
que deve ser aguardada. Como existem v√°rias formas de se trabalhar com ass√≠ncrono,
uma das mais conhecidas pelos usu√°rios JavaScript √© trabalhar com `callback`.
Existem muitas formas tamb√©m de se utilizar `callback`s, mas o padr√£o mais seguido
no JavaScript √© enviar uma fun√ß√£o de sucesso e uma fun√ß√£o de falha para um m√©todo
ass√≠ncrono.

```js
function successCallback(result) {
  console.log('It succeeded with ' + result);
}

function failureCallback(error) {
  console.log('It failed with ' + error);
}

doSomething(successCallback, failureCallback);
```

Olhando assim pode parecer simples, mas quando existem eventos encadeados, que
dependem da conclus√£o do anterior chegamos a um problema famoso, conhecido como
`callback hell`.

```js
a((resultFromA) => {
  b(resultFromA, (resultFromB) => {
    c(resultFromB, (resultFromC) => {
      d(resultFromC, (resultFromD) => {
        e(resultFromD, (resultFromE) => {
          f(resultFromE, (resultFromF) => {
            console.log(resultFromF);
          });
        });
      });
    });
  });
});
```

Com a chegada da `Promise`, conseguimos trabalhar de forma mais elegante, ainda
existe um encadeamento mas temos vantagens, como por exemplo, o `callback` passado
anteriormente s√≥ ser√° executado no fim do ciclo atual de execu√ß√£o do Event Loop,
enquanto a `Promise` n√£o depende disso. Para pegarmos o resultado de uma `Promise`
devemos utilizar a `keyword` `then`.

```js
a().then((resultFromA) => {
  return b(resultFromA)
})
.then((resultFromB) => {
  return c(resultFromB)
})
.then((resultFromC) => {
  return d(resultFromC)
})
.then((resultFromD) => {
  return e(resultFromD)
})
.then((resultFromE) => {
  return f(resultFromE)
})
.then((resultFromF) => {
  console.log(resultFromF)
})
```

Obviamente esses exemplos est√£o com muitos encadeamentos, o que n√£o √© t√£o comum,
mas quando aparecer um caso em que √© preciso muitos encadeamentos nem a `Promise`
vai resolver, mas ao menos se torna mais leg√≠vel e seguro de se utilizar.

### O objeto Promise

Acima mostrei como √© utilizada uma `Promise`, mas para cri√°-la existem algumas
formas e uma delas √© utilizando o objeto global `Promise`, dentro desse objeto
existem muitos m√©todos √∫teis para se trabalhar com `Promise`s, mas vou focar no
b√°sico.

A `Promise` pode ser criada com a `keyword` `new`, onde passamos uma fun√ß√£o que tem
nos par√¢metros duas fun√ß√µes, sendo elas, `resolve` e `reject`. O `resolve` retorna
o dado passado se a `Promise` for conclu√≠da, j√° o `reject` retorna um erro dessa
`Promise`.

```js
new Promise((resolve, reject) => {
  resolve(console.log('Initial'));
})
.then(() => {
  reject('Something failed');
  console.log('Do this');
})
.catch(() => {
  console.log('Do that');
})
.then(() => {
  console.log('Do this whatever happened before');
});
```

No log aparecer√°: Initial -> Do that -> Do this whatever happened before.

## Evoluindo com async e await

Existem muitos casos em que utilizar o `then` para aguardar uma `Promise` come√ßa
a ficar complexo, criando v√°rias `closures` em n√≠veis diferentes, foi ent√£o que
foi implementada no JavaScript a `feature` em que podemos criar uma `Promise`
a partir de uma fun√ß√£o comum, ao inv√©s de utilizar o objeto global.

Com as `keywords` `async` e `await` podemos trabalhar de forma imperativa
com a programa√ß√£o ass√≠ncrona como  se fosse s√≠ncrona.

```js
async function getGithubData() {
  return fetch('https://api.github.com/users/azagatti')
}
async function myPromise() {
  const response = await getGithubData()
  const data = await response.json()
  return data
}
console.log(await myPromise())
```

Normalmente n√£o seria poss√≠vel utilizar o `await` em um escopo fora de uma fun√ß√£o
com `async`, mas recentemente entrou uma nova `feature` no `v8` (principal engine
JavaScript), chamada [Top-level await](https://v8.dev/features/top-level-await),
assim podemos utilizar `await` fora de fun√ß√µes `async` em vers√µes mais
atualizadas de browsers e servers que rodam com `v8`.

Voltando ao foco, como no exemplo mostrado conseguimos aguardar opera√ß√µes ass√≠ncronas
para ent√£o executar outros processos s√≠ncronos, geralmente ajuda a manter a
legibilidade do c√≥digo e manter um c√≥digo limpo, criando novas vari√°veis e fun√ß√µes
descritivas. Vale lembrar que sempre que adicionamos o prefixo `async` em uma
fun√ß√£o, ela automaticamente se torna uma `Promise`, ou seja, quando formos utilizar
devemos utilizar o `then` ou `await`, ou ent√£o ela rodar√° e n√£o teremos nenhum
feedback, tem casos realmente que n√£o s√£o necess√°rios.

## Finaliza√ß√£o

Para finalizar, sempre utilize o `return` se for utilizar `then` dentro de uma
fun√ß√£o com `async`, ou ent√£o o compilador s√≥ ir√° ignorar e rodar em background,
o que recomendo √© escolher uma das abordagens para o caso, ou utiliza `async`
junto com `await` ou `then`. Tamb√©m Devo trazer outro artigo sobre os m√©todos que
podemos usar com a `Promise` j√° que s√£o muitos e tem muitas utilidades.

### Refer√™ncias:

- [Modelo de Concorr√™ncia e Event Loop](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/EventLoop)
- [Usando promises](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Using_promises)
- [Async functions - making promises friendly](https://developers.google.com/web/fundamentals/getting-started/primers/async-functions)
